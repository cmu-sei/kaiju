/***
 * CERT Kaiju
 * Copyright 2021 Carnegie Mellon University.
 *
 * NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
 * INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON UNIVERSITY
 * MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER
 * INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR
 * MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL.
 * CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT
 * TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
 *
 * Released under a BSD (SEI)-style license, please see LICENSE.md or contact permission@sei.cmu.edu for full terms.
 *
 * [DISTRIBUTION STATEMENT A] This material has been approved for public release and unlimited distribution.
 * Please see Copyright notice for non-US Government use and distribution.
 *
 * Carnegie Mellon (R) and CERT (R) are registered in the U.S. Patent and Trademark Office by Carnegie Mellon University.
 *
 * This Software includes and/or makes use of the following Third-Party Software subject to its own license:
 * 1. OpenJDK (http://openjdk.java.net/legal/gplv2+ce.html) Copyright 2021 Oracle.
 * 2. Ghidra (https://github.com/NationalSecurityAgency/ghidra/blob/master/LICENSE) Copyright 2021 National Security Administration.
 * 3. GSON (https://github.com/google/gson/blob/master/LICENSE) Copyright 2020 Google.
 * 4. JUnit (https://github.com/junit-team/junit5/blob/main/LICENSE.md) Copyright 2020 JUnit Team.
 * 5. Gradle (https://github.com/gradle/gradle/blob/master/LICENSE) Copyright 2021 Gradle Inc.
 * 6. markdown-gradle-plugin (https://github.com/kordamp/markdown-gradle-plugin/blob/master/LICENSE.txt) Copyright 2020 Andres Almiray.
 * 7. Z3 (https://github.com/Z3Prover/z3/blob/master/LICENSE.txt) Copyright 2021 Microsoft Corporation.
 * 8. jopt-simple (https://github.com/jopt-simple/jopt-simple/blob/master/LICENSE.txt) Copyright 2021 Paul R. Holser, Jr.
 *
 * DM21-0792
 */

// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the 
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra> 
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

//apply plugin: 'java' // adds 'test' task
//apply plugin: MarkdownPlugin // adds a markdownToHtml task, see buildSrc/ directory

plugins {
    id 'java'
    id 'kaiju.gradle.ghidrahtml'
}



//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
	ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
	ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}

if (ghidraInstallDir) {
	apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
}
else {
    throw new GradleException("GHIDRA_INSTALL_DIR is not defined!")
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------

def ghidraVersion;
def minor;
String[] str;
str = ghidraInstallDir.split('_');
for( String values : str )
if (values =~ '[0-9]{1,}\\.[0-9]{1,}\\.[0-9]{1,}') {
    ghidraVersion = values;
    String[] substr = values.split('\\.');
    minor = substr[1] as int;
};
if (minor && minor < 2) {
    // we target Java 11 LTS for old Ghidra
    sourceCompatibility = 1.11
    targetCompatibility = 1.11
} else {
    // we target Java 17 LTS for Ghidra 10.2+
    sourceCompatibility = 1.17
    targetCompatibility = 1.17
}

// allow installation using:
// > gradle -PGHIDRA_INSTALL_DIR=/path/to/ghidra install
// you can also allow removal of the any previous Kaiju install prior to
// reinstalling by adding -PKAIJU_AUTO_REMOVE

import org.gradle.util.VersionNumber

// Gradle 6.4+ is needed to compile the markdown gradle plugin written in groovy
// Ghidra 10 requires gradle 6.8 or above
if (VersionNumber.parse( gradle.gradleVersion ) <= VersionNumber.parse ("6.8.0")) {
    throw new GradleException("CERT Kaiju requires at least gradle version 6.8.0. Please update gradle and retry.")
}

// check for a java Z3CLASSPATH to be set, otherwise throw an exception.
// TODO: can we guess the defaults on different OSes? OpenSUSE installs jars into /usr/share/java, for example.
// NOTE: gradle seems to hijack the CLASSPATH env var when running, so we check for Z3CLASSPATH instead.
def z3ClasspathDir
if (System.env.Z3CLASSPATH) {
    z3ClasspathDir = System.env.Z3CLASSPATH
}
else if (project.hasProperty("Z3CLASSPATH")) {
    z3ClasspathDir = project.getProperty("Z3CLASSPATH")
}
if (!z3ClasspathDir) {
    throw new GradleException("Z3CLASSPATH is not defined! Please define as path to the z3 jar.")
}

repositories {
    mavenCentral()
    flatDir {
        dirs z3ClasspathDir
    }
}

dependencies {
    //testImplementation('org.junit.jupiter:junit-jupiter-api:5.4.2')
    //testRuntimeOnly('org.junit.jupiter:junit-jupiter-engine:5.4.2')
    //testRuntimeOnly('org.junit.vintage:junit-vintage-engine:5.4.2')
    //testRuntimeOnly('org.opentest4j:opentest4j:1.1.1')
    implementation(
        ':com.microsoft.z3:4.8.11.0'
    ) { because "Z3 is required to use Kaiju Ghihorn." }

    testImplementation(
        'junit:junit:4.12',
        'org.junit.jupiter:junit-jupiter-api:5.4.2',
        'org.junit.jupiter:junit-jupiter-engine:5.4.2',
        'org.junit.jupiter:junit-jupiter-migrationsupport:5.6.2'
    )
    testRuntimeOnly(
        'org.junit.jupiter:junit-jupiter-engine:5.4.2',
        'org.junit.vintage:junit-vintage-engine:5.4.2'
    )
}

// TODO: this tries to leave out the gradle plugin unnecessary for runtime Kaiju,
// but seems to fail. is there another way to configure this task defined by Ghidra?
// for now including the plugin source/binaries isn't harmful but is unnecessary.
buildExtension {
    excludes ['buildSrc/**']
}

task printGhidraDir {
    println 'Using Ghidra install directory ' + ghidraInstallDir
    println 'Using Java ' + targetCompatibility + ' for Ghidra ' + ghidraVersion
    println 'Using AUTOCATS test directory ' + project.property('KAIJU_AUTOCATS_DIR')
}

task copyToLib(type: Copy) {
    outputs.file file("lib/gson-2.8.6.jar")
    if (!file("lib/gson-2.8.6.jar").exists()) {
        configurations {
            gsonDependency
        }

        dependencies {
            gsonDependency group: 'com.google.code.gson', name: 'gson', version: '2.8.6'
        }

        from configurations.gsonDependency
        into "lib"
    }
    outputs.file file("lib/jopt-simple-5.0.4.jar")
    if (!file("lib/jopt-simple-5.0.4.jar").exists()) {
        configurations {
            joptDependency
        }

        dependencies {
            joptDependency group: 'net.sf.jopt-simple', name: 'jopt-simple', version: '5.0.4'
        }

        from configurations.joptDependency
        into "lib"
    }
    outputs.file file("lib/com.microsoft.z3-4.8.11.0.jar")
    if (!file("lib/com.microsoft.z3-4.8.11.0.jar").exists()) {
        configurations {
            z3Dependency
        }

        dependencies {
            z3Dependency name: 'com.microsoft.z3', version: '4.8.11.0'
        }

        from configurations.z3Dependency
        into "lib"
    }
}
copyDependencies.dependsOn(copyToLib)
buildExtension.dependsOn(copyToLib)
compileJava.dependsOn(copyToLib)
indexHelp.dependsOn(copyToLib)
indexHelp.dependsOn(markdownToGhidraHtml)
buildHelp.dependsOn(markdownToGhidraHtml)
zipSource.dependsOn(markdownToGhidraHtml)
markdownToGhidraHtml.sourceDir = file('docs/')
markdownToGhidraHtml.outputDir = file('src/main/help/help/topics/kaiju/')

task uninstallPreviousOOAnalyzerPlugin {

    group = "Installation"
    description = "Removes a previous OOAnalyzerPlugin installation, or notifies user of previous installation"
    
    doLast {
        
        // check if a previous OOAnalyzer installation exists
        if (file(ghidraInstallDir + '/Ghidra/Extensions/' + 'OOAnalyzerPlugin/').exists()) {
        
            // automatically remove past install if user specifies
            if (project.hasProperty('KAIJU_AUTO_REMOVE')) {
                //delete ghidraInstallDir + '/Ghidra/Extensions/' + 'OOAnalyzerPlugin/'
                def ooDir = new File(ghidraInstallDir + '/Ghidra/Extensions/' + 'OOAnalyzerPlugin/')
                ooDir.deleteDir()
                logger.quiet("SUCCESS! Previous standalone OOAnalyzerPlugin installation was removed automatically by gradle.")
            } else {
                throw new GradleException("FATAL ERROR! A previous installation of the standalone OOAnalyzerPlugin was detected. It is recommended that you either manually remove this installation before re-installing Kaiju, or re-run this gradle installation script with the -PKAIJU_AUTO_REMOVE option. Please note that the standalone plugin is now deprecated; we recommend you use the latest version included with Kaiju instead.")
            }
        }
    }
    
    outputs.upToDateWhen { false } // ensures never cached, always runs if user enables
    
    dependsOn buildExtension
}

task uninstallPreviousKaiju {

    group = "Installation"
    description = "Removes a previous Kaiju installation, or notifies user of previous installation"
    
    doLast {
    
        // check first if a previous Kaiju installation exists
        if (file(ghidraInstallDir + '/Ghidra/Extensions/' + 'kaiju/').exists()) {
        
            // automatically remove past install if user specifies
            if (project.hasProperty('KAIJU_AUTO_REMOVE')) {
                //delete ghidraInstallDir + '/Ghidra/Extensions/' + 'kaiju/'
                def kaijuDir = new File(ghidraInstallDir + '/Ghidra/Extensions/' + 'kaiju/')
                kaijuDir.deleteDir()
                logger.quiet("SUCCESS! Previous Kaiju installation was removed automatically by gradle.")
            } else {
                throw new GradleException("FATAL ERROR! A previous installation of Kaiju was detected. It is recommended that you either manually remove this installation before re-installing Kaiju, or re-run this gradle installation script with the -PKAIJU_AUTO_REMOVE option.")
            }
        }
    }
    
    outputs.upToDateWhen { false } // ensures never cached, always runs if user enables
    
    dependsOn uninstallPreviousOOAnalyzerPlugin
}

task copyZip(type: Copy) {

    group = "Installation"
    description = "Copies zip contents into special Extensions directory so user may enable or disable easily with reinstalling from gradle each time."

    from "$buildExtension.destinationDir/$buildExtension.baseName.$buildExtension.extension"
    into ghidraInstallDir + '/Extensions/Ghidra'
    
    dependsOn uninstallPreviousKaiju
}

task installZip(type: Exec) {
    
    group = "Installation"
    description = "Installs the zip package in installed Ghidra's default extension directory"

    workingDir ghidraInstallDir + '/Ghidra/Extensions'
    commandLine 'unzip', '-o', "$buildExtension.destinationDir/$buildExtension.baseName.$buildExtension.extension"
    
    dependsOn copyZip
    mustRunAfter copyZip
}

task install() {
     dependsOn installZip

     group = "Installation"
     description = "Alternate name for installZip task"
     //title = "Install zip"

     doLast {
        // Empty action list
        logger.quiet("Installed CERT Kaiju from zip!")
     }
}

test {

    // needed prior to Ghidra 10.3 to address sun.awt not exported in JDK 17+
    jvmArgs = ['--add-exports=java.desktop/sun.awt=ALL-UNNAMED']

    useJUnitPlatform()
    
    maxHeapSize = '2G'
    
    failFast = false
    
    testLogging {
        events "passed", "skipped", "failed"
	exceptionFormat = 'full'
    }
    
    beforeSuite { descriptor ->
    // check that user has specified the property AND set it (not empty)
    if (!project.hasProperty('KAIJU_AUTOCATS_DIR') || project.getProperty('KAIJU_AUTOCATS_DIR') == '') {
        throw new GradleException("FATAL ERROR! Kaiju requires specification of the directory where the AUTOCATS tests may be found. Please re-run the tests with the -PKAIJU_AUTOCATS_DIR=<path/to/autocats/dir> command option. Please consult the README.md for more information on AUTOCATS and how to obtain the AUTOCATS tests.")
    }
    
    // check that the specified directory actually exists
    if (!file(project.property('KAIJU_AUTOCATS_DIR')).exists()) {
        throw new GradleException("FATAL ERROR! The AUTOCATS path provided to Kaiju does not appear to exist. Please re-check the path then retry the -PKAIJU_AUTOCATS_DIR=<path/to/autocats/dir> command option. You may wish to provide the full absolute path to reduce errors. Please consult the README.md for more information on AUTOCATS and how to obtain the AUTOCATS tests.")
    }
    
    // TODO: how can we check if this path is actually an AUTOCATS path?
    // for now, just passing along the path and hoping for the best!
    }
    
    // only pass on the environment variable if was specified
    // this doesn't matter if it wasn't set, because the beforeSuite will execute
    // and abort if it wasn't set before running tests, and if you're not
    // running tests then it doesn't matter if it was set or not
    if (project.hasProperty('KAIJU_AUTOCATS_DIR')) {
        environment "KAIJU_AUTOCATS_DIR", project.property('KAIJU_AUTOCATS_DIR')
    }
    
    outputs.upToDateWhen { false } // ensures never cached, always runs if user enables
}
