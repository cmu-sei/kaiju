<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <META http-equiv="Content-Language" content="en-us">
    <META http-equiv="Content-Type" content="text/html; charset=windows-1252">

    <TITLE>OOAnalyzer JSON Importer Plugin</TITLE>
    <LINK rel="stylesheet" type="text/css" href="../../../shared/Frontpage.css">
    <META name="generator" content="Microsoft FrontPage 4.0">
    <STYLE>
ol.ratings li {
	margin: 0 0 10px 0;
}
    </STYLE>
  </HEAD>

  <BODY>
    <H1><A name="OOAnalyzerJsonImportAction"></A>OOAnalyzer JSON Importer Plugin</H1>

    <P>The OOAnalyzer Ghidra plugin is a standard Ghidra extension that can load, parse, and
    apply Pharos-generated OOAnalyzer results to object oriented C++ executables in a Ghidra
    project. When launched, the plugin will prompt the user for the JSON output file produced
    by OOAnalyzer that contains information about recovered C++ classes. After loading the JSON
    file, recovered C++ data types and symbols found by OOAnalyzer are updated in the Ghidra Code
    Browser. The plugin's design and implementation details are described in our SEI blog post
    titled <A HREF="https://insights.sei.cmu.edu/sei_blog/2019/07/using-ooanalyzer-to-reverse-engineer-object-oriented-code-with-ghidra.html">Using OOAnalyzer to Reverse Engineer Object Oriented Code with Ghidra</A>.</P>
    
    
    <H2>Using The Plugin</H2>
    
    <P>In the JSON file generated by OOAnalyzer contains information about the C++ classes found
    during analysis. OOAnalyzer-recovered classes will be named `cls_XXXXXX` by default.  The
    string of <B>X</B>s in the class name is an address-based identifier that is automatically
    generated.</P>

    <P>The plugin attempts to use the best representation of C++ data structures possible. To do this
    type information found by Ghidra will be combined with OOAnalyzer results as appropriate. In
    general, the plugin will favor which ever data type information is better defined. For example,
    if the Ghidra-defined types have more members defined than the OOAnalyzer-defined types, then the
    plugin will use the Ghidra-defined type.</P>

    <P>C++ classes can include both data members and methods. Unfortunately, there is not a single
    Ghidra window or view to capture these two aspects of classes in Ghidra's interface. Instead, the
    plugin uses a combination of the Ghidra Symbol Tree and Data Type Manager to model object-oriented
    data structures.</P>
    
    
    <H2>Symbol Tree</H2>
    
    <P>The Symbol Tree contains all the names and labels that are applied to a code listing. Perhaps
    the most important labels needed for analysis are function names, and in in the case of C++, class
    names and methods. The Symbol Tree uses a hierarchical layout for symbols organized in to
    namespaces. There is a global namespace and sub-directories for function and class labels. The
    plugin will add class names to the Symbol Tree *Classes* folder. Methods and virtual function tables
    will be added to class names directly to capture the compositional nature of C++ classes. For
    example, the Symbol Tree entry for a class may be organized as follows:</P>

```
Classes
   +- Cls_XXXXXX
      +- Cls_XXXXXXX (constructor)
      +- vftable_YYYYYY
      +- meth_1
      +- VIRT_FUN_1
```
    <H3>Namespace Configuration</H3>
    
    <P>You can configure how OOAnalyzer-updated class information is organized using the new
    <B>OOAnalyzer</B> namespace. By default, symbols that are updated or added by the plugin will be
    placed in to the OOAnalyzer namespace to enable analysts to see which types are updated and/or added.
    The most common case where this is useful is because OOAnalyzer often updates system classes for
    which Ghidra has incomplete definitions. For example, OOAnalyzer may determine that the standard
    exception class `std::exception` has three members, but Ghidra's stock type has none. In this case
    new members are added to the Ghidra type thereby changing its definition. Without moving the
    `std::exception` symbol to the OOAnalyzer namespace, this change would be lost.</P>

    <P>Using the OOAnalyzer namespace means that program labels in the listing will appear as fully
    qualified labels; for example, `OOAnalyzer::ClassName::MethodName`. While this makes it easy to
    determine which classes and methods have been updated by the plugin, it can lead to long, cluttered
    names in the Ghidra user interface. If this is problematic, then uncheck the box labeled <B>"Use
    OOAnalyzer namespace"</B> when the plugin is run.</P>
    
    
    <H2>Data Type Manager</H2>
    
    <P>The Data Type Manager contains the data types available for use during analysis, mostly organized
    by programming header file. All OOAnalyzer-generated structures will be organized in to a folder
    named <B>OOAnalyzer</B> in the Ghidra Data Type Manager. Each recovered class may be allocated two
    new structures. The primary structure for the recovered class contains the class members as structure
    components. A class may be allocated a second structure for virtual function tables if a virtual
    function table is defined. Virtual function tables will be labeled `cls_XXXXXX::vftable_YYYYYY`. As
    with class names, the <B>Y</B>'s are an address-based identifier assigned by OOAnalyzer that correspond
    to the address where the table is defined.</P>
    
    
    <H2>Running the Plugin</H2>
    
    <P>There are two ways to run the OOAnalyzer Plugin:</P>

    <OL>
        <LI>Launching it directly through the <kbd>CERT</kbd> menu</LI>
        <LI>Pressing the <kbd>F12</kbd> key, which is the shortcut for the plugin</LI>
    </OL>

    <P>When the Plugin is run, the *OOAnalyzer Setting* window will be displayed to configure and execute
    the plugin. To run the plugin, you must configure two settings: select the JSON file produced by
    OOAnalyzer and specify whether or not to organize new and updated classes into an OOAnalyzer namespace.
    Once these settings are configured, press <kbd>OK</kbd> to run the plugin.</P>
    
    <H3>Loading the JSON File</H3>
    
    <P>OOAnalyzer results are stored in a JSON file to be processed by the OOAnalyzer Ghidra Plugin. By
    default, the OOAnalyzer Ghidra Plugin expects a JSON file with the same name as the executable under
    analysis (i.e. if you are analyzer malware.exe, then the plugin expects a JSON file named malware.json).
    If you select a JSON file with a different name, then you must confirm that the correct file was
    selected.</P>
    

    <H2>Known Issues with Virtual Function Calls</H2>
    
    <P>We continue to explore the best way to model virtual function calls in Ghidra. Currently, the plugin
    uses dedicated structures for virtual function tables. This has the benefit of automatically being
    applied by Ghidra in a way that fills in virtual function call targets in the decompile view.
    Unfortunately, because these structures are defined statically in Ghidra we cannot model phenomena like
    dynamically assigned virtual function tables using these structures. This means that in cases where
    polymorphism is used the virtual function call listed in the decompilation may be the wrong one
    (technically, it will be the entry in the most distant parent virtual function table, not the child).
    We are working on addressing this problem.</P>
    
    
    <P align="center"><IMG border="1" src="images/build.png"></P>

    <P align="center">Building the plugin using Eclipse</P>
    
  </BODY>
</HTML>
